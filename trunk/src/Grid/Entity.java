/**
 * The abstract Entity class is derived from SimBaseEntity and is used as a
 * base starting point for all grid nodes. It is basically a network-aware
 * version of SimBaseEntity. It keeps track of the wavelengts used by this 
 * enitity.
 * 
 * @since version 2.0 
 * 
 * This entity also follows the MVC design pattern. We can plug in different
 * listeners {@link ChangeListener} which listen to events generated by this entity. This is mainly
 * for personal stat checking and updates. 
 * 
 * @version 2.0
 */
package Grid;

import Grid.OCS.OCSRoute;
import Grid.Interfaces.Messages.GridMessage;
import Grid.Port.GridOutPort;
import Grid.Routing.Routing;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import simbase.Exceptions.StopException;
import simbase.Port.SimBaseInPort;
import simbase.Port.SimBaseOutPort;
import simbase.SimBaseEntityImpl;
import simbase.SimBaseMessage;
import simbase.Stats.Logger;
import simbase.Time;


/**
 *
 * @author Jens Buysse
 */
public abstract class Entity extends SimBaseEntityImpl {

    /**
     * A list of used OCS Wavelengths which are used by this entity.
     */
    protected List<Integer> usedOCSWavelengths;
    /**
     * The gridsimulator.
     */
    protected GridSimulator gridSim;
    /**
     * Map containing mapping between outport and the time it is back free.
     */
    protected Map<GridOutPort, Map<Integer, Time>> linkUsage;
    /**
     * List of registred listeners.
     */
    protected EventListenerList listenerList = new EventListenerList();
    
    /**
     * ID for the OCS requests
     */
    public static int OCSRequestID = 0;

    /*******************************************************************
     **************************MVC PART********************************
     *******************************************************************/
    /**
     * Register a listener.
     */
    public void addChangeListener(ChangeListener l) {
        listenerList.add(ChangeListener.class, l);
    }

    /**
     * Undo registration
     */
    public void removeChangeListener(ChangeListener l) {
        listenerList.remove(ChangeListener.class, l);
    }
    /**
     * Unique change-event with this as a source.
     */
    private final ChangeEvent changeEvent = new ChangeEvent(this);

    /**
     * Handle a change Event and notify all listeners.
     */
    protected void fireStateChanged() {
        Object[] listeners = listenerList.getListenerList();
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == ChangeListener.class) {
                ((ChangeListener) listeners[i + 1]).stateChanged(changeEvent);
            }
        }
    }

    /**
     * Constructor - creates a Entity.
     * @param id The id of the enitity
     * @param simulator The simulator for which this entity belangs.
     */
    public Entity(String id, GridSimulator simulator) {
        super(id, simulator);
        inited = false;
        linkUsage = new TreeMap();
        this.gridSim = simulator;
    }

    @Override
    public void init() {
        usedOCSWavelengths = new ArrayList<Integer>();
        Iterator<SimBaseOutPort> it = this.getOutPorts().iterator();

        //initialise the wavelengts for the links
        while (it.hasNext()) {
            GridOutPort outPort = (GridOutPort) it.next();
            Map<Integer, Time> mappings = new TreeMap();
            for (int i = 0; i < outPort.getMaxNumberOfWavelengths(); i++) {
                mappings.put(new Integer(i), new Time(0));
            }
            linkUsage.put(outPort, mappings);
        }
        if (simulator != null) {
            inited = true;
            route();
            simulator.putLog(currentTime, id +
                    " successfully created.", Logger.BLACK, 0, 0);
        }
    }
    
    public abstract void route();

    /**
     * Checks wheter this outport is free (the entity is not sending on it)
     * @param port The port which has to be checked.
     * @param lambda The wavelength on which we want to send.
     * @param t The time when we want to send it.
     * @return True if it is free, false if not
     */
    public boolean isOutPortFree(GridOutPort port, int lambda, Time t) {
        Map<Integer, Time> map = linkUsage.get(port);
        if (map == null) {
            //the outport is not in the map
            return false;
        } else {
            //ouport in the map
            Time time = map.get(new Integer(lambda));
            if (time == null) {
                //link has never been used so it is free
                return true;
            } else {
                if (t.compareTo(time) > 0) {
                    //the link is free
                    return true;
                } else {
                    //link is not free
                    return false;
                }
            }
        }
    }

    /**
     * Finds a  wavelength that is free, given an outport (link) to take.
     * The way it is chosen is at random and when only one wavelength exist
     * 0 is chosen as the wavelength.
     * If all wavelengths are occupied, the return value is -1.
     * This method is used for the send routines in the network, NOT to find
     * a free wavelength to set up a OCS-circuit. 
     * @param port The GridOutPort on which the message needs to be send.
     * @return A positive integer (wavelength), or -1 if all wavelengths are occupied.
     */
    public int findWaveLength(GridOutPort port, Time refTime) {
        Map<Integer, Time> map = linkUsage.get(port);
        int maxWaveLengths = port.getMaxNumberOfWavelengths();
        if (maxWaveLengths > 0) {

            for (int iterator = 0; iterator < maxWaveLengths; iterator++) {
                if (!port.isWaveUsedInCircuit(iterator)) {
                    Integer wave = iterator;
                    Time time = map.get(wave);
                    if (time.compareTo(refTime) < 0) {
                        int waveValue = wave.intValue();
                        return waveValue;
                    }
                }
            }
        }
        return -1;
    }

    /**
     * Calculates the distance/hopcount/... to a given nextHop.
     * 
     * @param destination
     *            the nextHop node inside the grid
     * @return the distance parameter. -1 if no connection exists between the 
     * two GridEntitys.
     */
    public int getHopCount(Entity destination) {
        GridSimulator sim = (GridSimulator) simulator;
        Routing routing = sim.getRouting();
        return routing.getNrOfHopsBetween(this, destination);
    }

    /**
     * Find an outgoing port, given his id.
     * @param id The id of the outgoing port.
     * @return The outgoing
     */
    public GridOutPort getOutport(String id) {
        Iterator it = getOutPorts().iterator();
        while (it.hasNext()) {
            GridOutPort port = (GridOutPort) it.next();
            if (port.getID().equals(id)) {
                return port;
            }
        }
        return null;
    }
    
        /**
     * Find an outgoing port to a given destination entity.
     * @param id The desitnation entity
     * @return The outgoing
     */
    public GridOutPort getOutportTo(Entity entity) {
        Iterator it = getOutPorts().iterator();
        while (it.hasNext()) {
            GridOutPort port = (GridOutPort) it.next();
            if (port.getID().endsWith(entity.getId())) {
                return port;
            }
        }
        return null;
    }

    /**
     * Returns the Gridsimulator.
     * @return The Gridsimulator.
     */
    public GridSimulator getGridSim() {
        return gridSim;
    }

    /**
     * Sets the Gridsimulator for this entity.
     * @param gridSim The new GridSimulator.
     */
    public void setGridSim(GridSimulator gridSim) {
        this.gridSim = gridSim;
    }

    /**
     * Returns the inited flag.
     * @return True if it is inited, false if not.
     */
    @Override
    public boolean isInited() {
        return inited;
    }

    /**
     * Sets the inited flag.
     * @param inited The new init flag.
     */
    public void setInited(boolean inited) {
        this.inited = inited;
    }


    /**
     * Does this entity supports OCS?
     * 
     * @return true if OCS is supported
     */
    public abstract boolean supportsOCS();

    /**
     * Does this entity supports OBS?
     * 
     * @return true if OBS is supported
     */
    public abstract boolean supportsOBS();

    /**
     * Does this enitity support swithing? Can it forward traffic?
     * 
     * @return true if it support swithin, false if not.
     */
    public abstract boolean supportSwitching();

    /**
     * Returns a list of uses wavelenghts by setup circuits.
     * @return The used ocs-circuit-wavelengths
     */
    public List<Integer> getUsedOCSWavelengths() {
        return usedOCSWavelengths;
    }

    /**
     * Sets the list witch used wavelengths.
     * @param usedOCSWavelengths A new set of used ocs wavelengths
     */
    public void setUsedOCSWavelengths(List<Integer> usedOCSWavelengths) {
        this.usedOCSWavelengths = usedOCSWavelengths;
    }

    @Override
    public void receive(SimBaseInPort inPort, SimBaseMessage m) throws StopException {
        ((GridMessage) m).addHop(this); 
        fireStateChanged();
    }

    /**
     * Request an OCS-circuit.
     * @param ocsRoute The route for the circuit.
     * @param permanent Is it setup on the fly by the entity (is the enitity also responsible for the tear down)
     * or should the circuit be permanent.
     * @param time The time when the request should be made.
     */
    public abstract void requestOCSCircuit(OCSRoute ocsRoute, boolean permanent, Time time);

    /**
     * Tear down an existing OCS-circuit.
     * @param ent The enitity which asks it. (TODO: is this still necessqry)
     * @param wavelength The wavelength to tear down.
     * @param port The begin port of the circuit.
     * @param time The time this request should be made. (Advace tear down).
     */
    public abstract void teardDownOCSCircuit(Entity ent, int wavelength, GridOutPort port, Time time);

    /**
     * Will find the ouport to go to nextHop. If there are more routes to 
     * the nextHop then the first encoutered will be returned.
     * @param nextHop The nextHop to be reached by this outport.
     * @return The first outport pointing to the nextHop, or null if there is none.
     */
    public GridOutPort findOutPort(Entity nextHop) {
        Iterator<SimBaseOutPort> it = outPorts.iterator();
        while (it.hasNext()) {
            GridOutPort port = (GridOutPort) it.next();
            if (port.getID().startsWith(id) && port.getID().endsWith(nextHop.getId())) {
                return port;
            }
        }
        return null;
    }

    /**
     * Will find the outport to the given nextHop using the wavelength
     * for this the circuit (if OCS is used). If multiple routes exist to nextHop
     * the first encoutered shall be returned
     * @param nextHop The next hop to reach
     * @param wavelength The wavelength from the circuit to reach is.
     * @return The gridouport if found, null if nothing is found.
     */
    public GridOutPort findOutPort(Entity nextHop, int wavelength) {
        Iterator<SimBaseOutPort> it = outPorts.iterator();
        while (it.hasNext()) {
            GridOutPort port = (GridOutPort) it.next();
            if (port.getID().startsWith(id) && port.getID().endsWith(nextHop.getId())) {
                if (port.isWaveUsedInCircuit(wavelength)) {
                    return port;
                }
            }
        }
        return null;
    }

    public int findFreeOCSWavelength(GridOutPort outPort) {
        return outPort.getNexFreeWavelength();
    }

    public Map<GridOutPort, Map<Integer, Time>> getLinkUsage() {
        return linkUsage;
    }
    
    
}
